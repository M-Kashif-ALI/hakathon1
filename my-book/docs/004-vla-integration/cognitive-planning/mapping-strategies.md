---
sidebar_position: 500
title: Mapping Strategies from LLM-Generated Plans to ROS 2 Behaviors
---

# Mapping Strategies from LLM-Generated Plans to ROS 2 Behaviors

This section documents various strategies for mapping high-level plans generated by Large Language Models to concrete ROS 2 behaviors and actions that can be executed by robotic systems.

## Overview

The mapping process is critical for connecting abstract LLM-generated plans to concrete robotic actions. This involves translating:
- High-level action concepts to specific ROS 2 action servers
- Natural language parameters to structured ROS 2 messages
- Conditional logic to ROS 2 behavior trees
- Error handling strategies to ROS 2 recovery behaviors

## 1. Direct Mapping Strategy

The simplest approach maps LLM action types directly to ROS 2 action servers:

```python
class DirectMapper:
    def __init__(self):
        self.action_mapping = {
            'navigate': 'navigate_to_pose',
            'manipulate': 'follow_joint_trajectory',
            'perceive': 'object_detection',
            'communicate': 'text_to_speech'
        }

    def map_action(self, llm_action):
        """
        Directly map LLM action to ROS 2 action
        """
        action_type = llm_action.get('type')

        if action_type in self.action_mapping:
            ros2_action = self.action_mapping[action_type]
            parameters = self.convert_parameters(llm_action.get('parameters', {}))

            return {
                'ros2_action': ros2_action,
                'parameters': parameters,
                'description': llm_action.get('description')
            }

        return None  # Unsupported action type

    def convert_parameters(self, llm_params):
        """
        Convert LLM parameters to ROS 2 message format
        """
        ros2_params = {}

        for key, value in llm_params.items():
            # Convert parameter names and values to ROS 2 format
            ros2_key = self.convert_param_name(key)
            ros2_value = self.convert_param_value(value)
            ros2_params[ros2_key] = ros2_value

        return ros2_params

    def convert_param_name(self, name):
        """
        Convert parameter name to ROS 2 convention
        """
        conversion_map = {
            'x': 'pose.position.x',
            'y': 'pose.position.y',
            'theta': 'pose.orientation',
            'object': 'target_object',
            'action': 'manipulation_type'
        }
        return conversion_map.get(name, name)

    def convert_param_value(self, value):
        """
        Convert parameter value to appropriate ROS 2 type
        """
        if isinstance(value, (int, float)):
            return float(value)
        elif isinstance(value, str):
            # Convert string representations to appropriate formats
            if value.lower() in ['true', 'false']:
                return value.lower() == 'true'
            return value
        return value
```

## 2. Semantic Mapping Strategy

This strategy uses semantic understanding to map similar concepts:

```python
class SemanticMapper:
    def __init__(self):
        self.semantic_map = {
            # Navigation actions
            'go_to': ['navigate_to_pose'],
            'move_to': ['navigate_to_pose'],
            'travel_to': ['navigate_to_pose'],
            'drive_to': ['navigate_to_pose'],

            # Manipulation actions
            'pick_up': ['grasp_object'],
            'grasp': ['grasp_object'],
            'take': ['grasp_object'],
            'hold': ['grasp_object'],
            'place': ['place_object'],
            'put': ['place_object'],
            'release': ['release_object'],

            # Perception actions
            'look_at': ['object_detection'],
            'find': ['object_detection'],
            'search_for': ['object_detection'],
            'see': ['object_detection'],

            # Communication actions
            'say': ['text_to_speech'],
            'speak': ['text_to_speech'],
            'tell': ['text_to_speech'],
            'communicate': ['text_to_speech']
        }

    def map_with_semantics(self, llm_action):
        """
        Map action using semantic understanding
        """
        action_desc = llm_action.get('description', '').lower()

        # Find best semantic match
        best_match = self.find_semantic_match(action_desc)

        if best_match:
            return {
                'ros2_action': best_match,
                'parameters': self.extract_semantic_parameters(llm_action),
                'confidence': self.calculate_semantic_confidence(action_desc, best_match)
            }

        return None

    def find_semantic_match(self, action_description):
        """
        Find the best semantic match for an action description
        """
        import re

        for llm_term, ros2_actions in self.semantic_map.items():
            if llm_term in action_description:
                # Return the first matching ROS 2 action
                return ros2_actions[0]

        # If no direct match, use more sophisticated NLP
        return self.nlp_based_mapping(action_description)

    def nlp_based_mapping(self, action_description):
        """
        Use NLP techniques for more sophisticated mapping
        """
        # This could use techniques like:
        # - Word embeddings similarity
        # - Named entity recognition
        # - Dependency parsing
        # For now, return a default action
        return 'unknown_action'

    def extract_semantic_parameters(self, llm_action):
        """
        Extract parameters using semantic understanding
        """
        description = llm_action.get('description', '')
        params = llm_action.get('parameters', {})

        # Extract object names, locations, etc. from description
        extracted = self.extract_entities(description)
        extracted.update(params)  # Override with explicit parameters

        return extracted

    def extract_entities(self, text):
        """
        Extract entities from text (simplified version)
        """
        import re

        entities = {}

        # Extract coordinates
        coord_pattern = r'(\d+\.?\d*)\s*,?\s*(\d+\.?\d*)'
        coords = re.findall(coord_pattern, text)
        if coords:
            entities['x'] = float(coords[0][0])
            entities['y'] = float(coords[0][1])

        # Extract object names
        object_keywords = ['cup', 'bottle', 'book', 'box', 'table', 'chair']
        for keyword in object_keywords:
            if keyword in text.lower():
                entities['target_object'] = keyword
                break

        return entities

    def calculate_semantic_confidence(self, description, matched_action):
        """
        Calculate confidence in semantic mapping
        """
        # Simple confidence based on keyword presence
        keywords = description.split()
        confidence = min(len(keywords) * 0.1, 0.9)  # Base confidence
        return confidence
```

## 3. Template-Based Mapping Strategy

Use predefined templates for common action patterns:

```python
class TemplateMapper:
    def __init__(self):
        self.action_templates = {
            'navigation_to_location': {
                'llm_pattern': r'go to the (\w+)|navigate to (\w+)|move to (\w+)',
                'ros2_action': 'navigate_to_pose',
                'parameter_extractor': self.extract_location_coordinates
            },
            'object_manipulation': {
                'llm_pattern': r'(pick up|grasp|take) the (\w+)',
                'ros2_action': 'manipulate_object',
                'parameter_extractor': self.extract_object_details
            },
            'object_place': {
                'llm_pattern': r'place|put the (\w+) on the (\w+)',
                'ros2_action': 'place_object',
                'parameter_extractor': self.extract_place_details
            }
        }

    def map_with_templates(self, llm_action):
        """
        Map action using predefined templates
        """
        description = llm_action.get('description', '')

        for template_name, template in self.action_templates.items():
            import re
            match = re.search(template['llm_pattern'], description, re.IGNORECASE)

            if match:
                # Extract parameters using template's extractor
                params = template['parameter_extractor'](description, match.groups())

                return {
                    'ros2_action': template['ros2_action'],
                    'parameters': params,
                    'template_used': template_name,
                    'confidence': 0.9  # High confidence for template match
                }

        return None

    def extract_location_coordinates(self, description, groups):
        """
        Extract location coordinates based on location name
        """
        location_name = groups[0] if groups else 'unknown'

        # In a real system, this would look up coordinates in a map
        location_map = {
            'kitchen': {'x': 5.0, 'y': 3.0},
            'living room': {'x': 2.0, 'y': 1.0},
            'office': {'x': 8.0, 'y': 5.0},
            'bedroom': {'x': 1.0, 'y': 4.0}
        }

        coords = location_map.get(location_name.lower(), {'x': 0.0, 'y': 0.0})
        return coords

    def extract_object_details(self, description, groups):
        """
        Extract object details for manipulation
        """
        object_name = groups[-1] if groups else 'unknown'

        return {
            'object_name': object_name,
            'manipulation_type': 'grasp',
            'approach_angle': 0.0
        }

    def extract_place_details(self, description, groups):
        """
        Extract placement details
        """
        if len(groups) >= 2:
            object_name = groups[0]
            target_location = groups[1]
        else:
            object_name = 'unknown'
            target_location = 'unknown'

        return {
            'object_name': object_name,
            'target_location': target_location,
            'placement_type': 'place'
        }
```

## 4. Behavior Tree Mapping Strategy

Map LLM plans to ROS 2 behavior trees for complex task execution:

```python
import py_trees
from py_trees.behaviours import SuccessAlways, FailureAlways
from py_trees.composites import Sequence, Selector, Parallel
from py_trees.decorators import Retry, Timeout

class BehaviorTreeMapper:
    def __init__(self, node):
        self.node = node

    def map_to_behavior_tree(self, llm_plan):
        """
        Convert LLM plan to ROS 2 behavior tree
        """
        root = Sequence(name="LLM_Plan_Root")

        for i, step in enumerate(llm_plan):
            behavior = self.create_behavior_for_step(step, i)
            root.add_child(behavior)

        return root

    def create_behavior_for_step(self, step, step_index):
        """
        Create behavior tree node for individual LLM plan step
        """
        action_type = step.get('type', 'unknown')

        if action_type == 'navigate':
            return self.create_navigation_behavior(step, step_index)
        elif action_type == 'manipulate':
            return self.create_manipulation_behavior(step, step_index)
        elif action_type == 'perceive':
            return self.create_perception_behavior(step, step_index)
        elif action_type == 'communicate':
            return self.create_communication_behavior(step, step_index)
        else:
            # Fallback for unknown actions
            return SuccessAlways(name=f"Unknown_Action_{step_index}")

    def create_navigation_behavior(self, step, step_index):
        """
        Create navigation behavior with error handling
        """
        # Create the navigation task
        nav_task = NavigationTask(
            self.node,
            step.get('parameters', {}),
            step.get('description', '')
        )

        # Add timeout decorator
        nav_with_timeout = Timeout(
            name=f"NavTimeout_{step_index}",
            duration=60.0,  # 60 second timeout
            child=nav_task
        )

        # Add retry decorator
        nav_with_retry = Retry(
            name=f"NavRetry_{step_index}",
            num_attempts=3,
            child=nav_with_timeout
        )

        return nav_with_retry

    def create_manipulation_behavior(self, step, step_index):
        """
        Create manipulation behavior with verification
        """
        manip_task = ManipulationTask(
            self.node,
            step.get('parameters', {}),
            step.get('description', '')
        )

        # Add verification step after manipulation
        verification_task = ManipulationVerificationTask(self.node)

        sequence = Sequence(name=f"ManipSequence_{step_index}")
        sequence.add_child(manip_task)
        sequence.add_child(verification_task)

        return sequence

class NavigationTask(py_trees.behaviour.Behaviour):
    def __init__(self, node, parameters, description=""):
        super().__init__(name=f"NavigationTask_{hash(description) % 10000}")
        self.node = node
        self.parameters = parameters
        self.description = description
        self.nav_client = None
        self.goal_handle = None

    def initialise(self):
        """
        Initialize navigation action
        """
        from rclpy.action import ActionClient
        from nav2_msgs.action import NavigateToPose

        self.nav_client = ActionClient(self.node, NavigateToPose, 'navigate_to_pose')

        # Create navigation goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'

        pos = self.parameters
        goal_msg.pose.pose.position.x = pos.get('x', 0.0)
        goal_msg.pose.pose.position.y = pos.get('y', 0.0)
        goal_msg.pose.pose.position.z = 0.0

        # Set orientation
        theta = pos.get('theta', 0.0)
        from math import sin, cos
        goal_msg.pose.pose.orientation.z = sin(theta / 2.0)
        goal_msg.pose.pose.orientation.w = cos(theta / 2.0)

        # Send goal
        self.nav_client.wait_for_server()
        future = self.nav_client.send_goal_async(goal_msg)
        future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """
        Handle goal response
        """
        self.goal_handle = future.result()
        if not self.goal_handle.accepted:
            self.feedback_message = "Navigation goal rejected"
            return

        result_future = self.goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def result_callback(self, future):
        """
        Handle result
        """
        result = future.result().result
        self.feedback_message = f"Navigation result: {result}"

    def update(self):
        """
        Update behavior status
        """
        if self.goal_handle is None:
            return py_trees.common.Status.RUNNING

        # Check goal status
        if self.goal_handle.status == 3:  # STATUS_SUCCEEDED
            return py_trees.common.Status.SUCCESS
        elif self.goal_handle.status == 4:  # STATUS_CANCELED
            return py_trees.common.Status.FAILURE
        elif self.goal_handle.status == 5:  # STATUS_ABORTED
            return py_trees.common.Status.FAILURE
        else:
            return py_trees.common.Status.RUNNING
```

## 5. Conditional Mapping Strategy

Handle conditional logic in LLM plans:

```python
class ConditionalMapper:
    def __init__(self, node):
        self.node = node

    def map_conditional_plan(self, llm_plan):
        """
        Map plan with conditional logic
        """
        root = Sequence(name="Root_Sequence")

        for step in llm_plan:
            if step.get('type') == 'conditional':
                conditional_node = self.create_conditional_node(step)
                root.add_child(conditional_node)
            else:
                # Regular action
                action_node = self.create_regular_action_node(step)
                root.add_child(action_node)

        return root

    def create_conditional_node(self, conditional_step):
        """
        Create conditional behavior tree node
        """
        condition = conditional_step.get('parameters', {}).get('condition', '')
        true_actions = conditional_step.get('parameters', {}).get('true_actions', [])
        false_actions = conditional_step.get('parameters', {}).get('false_actions', [])

        # Create selector (try-if-else pattern)
        selector = Selector(name=f"Conditional_{hash(condition) % 10000}")

        # Check condition branch
        condition_checker = ConditionChecker(self.node, condition)
        condition_sequence = Sequence(name="Condition_Check")
        condition_sequence.add_child(condition_checker)

        # True branch
        true_branch = Sequence(name="True_Branch")
        for action in true_actions:
            action_node = self.create_regular_action_node(action)
            true_branch.add_child(action_node)

        # False branch
        false_branch = Sequence(name="False_Branch")
        for action in false_actions:
            action_node = self.create_regular_action_node(action)
            false_branch.add_child(action_node)

        # Combine with selector
        condition_with_true = Sequence(name="Condition_True")
        condition_with_true.add_child(condition_checker)
        condition_with_true.add_child(true_branch)

        selector.add_child(condition_with_true)

        # Add false branch as fallback
        selector.add_child(false_branch)

        return selector

class ConditionChecker(py_trees.behaviour.Behaviour):
    def __init__(self, node, condition):
        super().__init__(name=f"Check_{condition}")
        self.node = node
        self.condition = condition
        self.satisfied = False

    def update(self):
        """
        Check if condition is satisfied
        """
        # This would check actual robot sensors/environment
        # For example: check if person is detected, object is present, etc.
        self.satisfied = self.check_condition()

        if self.satisfied:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE

    def check_condition(self):
        """
        Check the specific condition
        """
        # Implementation would depend on the condition type
        # This is a placeholder
        return True  # or False based on actual sensor data
```

## 6. Adaptive Mapping Strategy

Adjust mapping based on execution feedback and learning:

```python
class AdaptiveMapper:
    def __init__(self, node):
        self.node = node
        self.mapping_history = {}
        self.success_rates = {}
        self.current_environment = "default"

    def adaptive_map(self, llm_action):
        """
        Map action adaptively based on context and history
        """
        action_key = self.get_action_key(llm_action)

        # Check if we have learned a better mapping for this environment
        if self.has_learned_mapping(action_key):
            return self.get_learned_mapping(action_key)

        # Otherwise, use standard mapping
        standard_mapping = self.standard_mapping(llm_action)

        # Store for potential learning
        self.record_mapping_attempt(action_key, standard_mapping)

        return standard_mapping

    def has_learned_mapping(self, action_key):
        """
        Check if we have learned a better mapping
        """
        env_key = f"{self.current_environment}_{action_key}"
        return env_key in self.mapping_history

    def get_learned_mapping(self, action_key):
        """
        Get learned mapping for current context
        """
        env_key = f"{self.current_environment}_{action_key}"
        return self.mapping_history[env_key]

    def record_mapping_attempt(self, action_key, mapping_result):
        """
        Record mapping attempt for learning
        """
        env_key = f"{self.current_environment}_{action_key}"

        if env_key not in self.mapping_history:
            self.mapping_history[env_key] = []

        self.mapping_history[env_key].append({
            'mapping': mapping_result,
            'timestamp': self.node.get_clock().now().nanoseconds
        })

    def update_mapping_success(self, action_key, success):
        """
        Update success rate for a mapping
        """
        env_key = f"{self.current_environment}_{action_key}"

        if env_key not in self.success_rates:
            self.success_rates[env_key] = {'success': 0, 'total': 0}

        stats = self.success_rates[env_key]
        stats['total'] += 1
        if success:
            stats['success'] += 1

    def get_action_key(self, llm_action):
        """
        Generate key for action type
        """
        action_type = llm_action.get('type', 'unknown')
        description = llm_action.get('description', '')
        return f"{action_type}_{hash(description) % 1000}"

    def standard_mapping(self, llm_action):
        """
        Standard mapping fallback
        """
        # Use one of the other mapping strategies as fallback
        direct_mapper = DirectMapper()
        return direct_mapper.map_action(llm_action)
```

## 7. Validation and Error Handling Strategies

Ensure mappings are valid and handle errors gracefully:

```python
class ValidatingMapper:
    def __init__(self, node):
        self.node = node
        self.supported_actions = {
            'navigate': ['x', 'y', 'theta'],
            'manipulate': ['action', 'object'],
            'perceive': ['target'],
            'communicate': ['message']
        }

    def validate_and_map(self, llm_plan):
        """
        Validate and map the entire plan
        """
        validated_plan = []

        for i, step in enumerate(llm_plan):
            try:
                # Validate individual step
                is_valid, error_msg = self.validate_step(step)

                if not is_valid:
                    self.node.get_logger().warn(f'Step {i} validation failed: {error_msg}')
                    # Try to fix or skip
                    fixed_step = self.attempt_fix(step)
                    if fixed_step:
                        validated_plan.append(fixed_step)
                    continue

                # Map the validated step
                mapped_step = self.map_step(step)
                if mapped_step:
                    validated_plan.append(mapped_step)

            except Exception as e:
                self.node.get_logger().error(f'Error mapping step {i}: {e}')
                # Add error recovery step
                validated_plan.extend(self.create_recovery_steps(e))

        return validated_plan

    def validate_step(self, step):
        """
        Validate individual step
        """
        action_type = step.get('type')
        if not action_type:
            return False, "Missing action type"

        if action_type not in self.supported_actions:
            return False, f"Unsupported action type: {action_type}"

        required_params = self.supported_actions[action_type]
        parameters = step.get('parameters', {})

        for param in required_params:
            if param not in parameters:
                return False, f"Missing required parameter '{param}' for action '{action_type}'"

        return True, "Valid"

    def attempt_fix(self, step):
        """
        Attempt to fix an invalid step
        """
        action_type = step.get('type', 'unknown')
        parameters = step.get('parameters', {})

        # Try to infer missing parameters
        if action_type == 'navigate':
            if 'x' not in parameters or 'y' not in parameters:
                # Use default coordinates or last known position
                parameters.setdefault('x', 0.0)
                parameters.setdefault('y', 0.0)
                parameters.setdefault('theta', 0.0)
                return {**step, 'parameters': parameters}

        elif action_type == 'communicate':
            if 'message' not in parameters:
                # Use default message
                parameters['message'] = "Unable to execute command"
                return {**step, 'parameters': parameters}

        return None  # Could not fix

    def create_recovery_steps(self, error):
        """
        Create recovery steps for error handling
        """
        recovery_plan = []

        # Add error reporting step
        recovery_plan.append({
            'type': 'communicate',
            'parameters': {
                'message': f"Error occurred: {str(error)}. Pausing for human assistance."
            },
            'description': 'Report error to human operator'
        })

        # Add safe state step
        recovery_plan.append({
            'type': 'navigate',
            'parameters': {'x': 0.0, 'y': 0.0, 'theta': 0.0},
            'description': 'Return to safe position'
        })

        return recovery_plan
```

## Integration Strategies

Combine multiple mapping strategies for robust performance:

```python
class HybridMapper:
    def __init__(self, node):
        self.node = node
        self.mappers = {
            'direct': DirectMapper(),
            'semantic': SemanticMapper(),
            'template': TemplateMapper(),
            'behavior_tree': BehaviorTreeMapper(node),
            'adaptive': AdaptiveMapper(node),
            'validating': ValidatingMapper(node)
        }

    def map_with_fallbacks(self, llm_plan):
        """
        Use multiple mapping strategies with fallbacks
        """
        strategies = ['template', 'semantic', 'direct']  # Order of preference

        for strategy_name in strategies:
            try:
                mapper = self.mappers[strategy_name]

                if strategy_name == 'behavior_tree':
                    # Special handling for behavior tree mapper
                    result = mapper.map_to_behavior_tree(llm_plan)
                else:
                    result = self.apply_mapper(mapper, llm_plan)

                # Validate result
                if self.validate_mapping_result(result):
                    self.node.get_logger().info(f'Used {strategy_name} mapping strategy')
                    return result

            except Exception as e:
                self.node.get_logger().warn(f'{strategy_name} mapping failed: {e}')
                continue

        # All strategies failed
        raise Exception("All mapping strategies failed")

    def apply_mapper(self, mapper, llm_plan):
        """
        Apply a specific mapper to the plan
        """
        mapped_plan = []
        for step in llm_plan:
            mapped_step = mapper.map_action(step)
            if mapped_step:
                mapped_plan.append(mapped_step)

        return mapped_plan

    def validate_mapping_result(self, result):
        """
        Validate that mapping result is usable
        """
        if result is None:
            return False

        # For behavior trees
        if hasattr(result, 'root'):
            return result.root is not None

        # For plan lists
        if isinstance(result, list):
            return len(result) > 0

        return True
```

These mapping strategies provide various approaches to connect LLM-generated plans to ROS 2 behaviors, each with different strengths for different scenarios and requirements.